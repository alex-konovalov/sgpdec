#############################################################################
##
## TUTORIAL #01 Cascaded Structures          SgpDec package  
##
## Copyright (C)  Attila Egri-Nagy, Chrystopher L. Nehaniv
##
## 2008 University of Hertfordshire, Hatfield, UK
##
## Tutorial for working with cascaded structures
##
##
## This is a runnable script 
## 
## gap < 01_cascade.g
## 
## from command line. Or in GAP
##
## Read("01_cascade.g");
##
## However it is recommended to go through the commands and issue them separately to see how they work.
## When loaded into GAP the variables are available for experimenting with them. 


#switch to fancier display (this dies on bigger groups)
SMALL_GROUPS := true;

# CREATING CASCADED STRUCTURES

# The information needed for describing a particular cascaded product (as a substructure of the wreath product) is stored in a record. The record can be created by giving the components. (For component names check namegroups.g and namedsemigroups.g in /gap )
cascaded_monoid := CascadedStructure([Z5,FlipFlop,Z5]);

#For some small groups the symbols are available automatically (from groupinfo dir). If symbol data is not available or in case of semigroups (for the time being) the permutations or transformation stands for itself.
#Alternatively, functions mappings points(states) and operations to symbols can be given. TODO!! example 

#CREATING ELEMENTS A CASCADED PRODUCT

#For creating product elements from scratch the product info record is needed.
#random one, the number of  nontrivial entries in the dependency tree must be given 
rnd := RandomCascadedOperation(cascaded_monoid,5);
#dependency functions giving the neutral element
id := IdentityCascadedOperation(cascaded_monoid);

#for defining one new element elementary dependency function maps should be given. Real elements (not the corresponding symbols should be used here).
defd := DefineCascadedOperation(cascaded_monoid,[ [[],(1,2,3,4,5)], [[1],Transformation([1,1])], [[2,2],(1,2,3,4,5)] ]);

#for the other direction we can extract those dependency pairs
dependencies := DependencyMapsFromCascadedOperation(defd);
#just for checking this gives true, but clearly the extracted dependencies can be manipulated easily
defd := DefineCascadedOperation(cascaded_monoid,dependencies);

#creating cascops from existing one (i.e. the multiplication in the product)
co := rnd * defd;
defd5 := defd^5;


#CREATING CASCADED STATES AND THE ACTION

#again the info record should be added
cs := CascadedState(cascaded_monoid,[1,1,1]);

#the action:
cs2 := cs * defd;

#FLATTENING going from the product to normal permutations/transformations
fcs := Collapse(cs);
fco := Collapse(co);

#RAISING, going from permutations/transformations the info record should be given (we need to know where to raise to)
rfcs := Build(cascaded_monoid,fcs);
rfco := Build(cascaded_monoid,fco);

#OUTPUT Display(cascadedobject) can be used, and for GraphViz printing a filename should be given, the output will be in filename.dot, a label also should be given 
Draw(co,"co","rnd*defd");


#STUDYING THE WHOLE STRUCTURE
#it is possible to define Groups/Semigroups generated by cascaded operations
s := SemigroupByGenerators([rnd,defd]);
#but the representation and calculation with cascaded operations are quite expensive so it's better to work with the flattened generators, look for some interesting elements, then raise them back to the cascaded to see how they look like in coordinatised form
s := SemigroupByGenerators([Collapse(rnd),Collapse(defd)]);


